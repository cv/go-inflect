//go:build ignore

// gen-exports generates re-export wrappers for the root package.
//
// Usage:
//
//	go run ./cmd/gen-exports
package main

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/doc"
	"go/format"
	"go/parser"
	"go/token"
	"log"
	"os"
	"strings"
)

const (
	internalPkg = "./internal/inflect"
	importPath  = "github.com/cv/go-inflect/v2/internal/inflect"
	implAlias   = "impl"
	outputFile  = "inflect_gen.go"
)

// stdLibImports maps types from standard library packages that need to be imported.
// Key is the type name as it appears in the code, value is the import path.
var stdLibImports = map[string]string{
	"template.FuncMap": "text/template",
}

// neededImports tracks which standard library imports are needed
var neededImports = make(map[string]bool)

func main() {
	fset := token.NewFileSet()
	docPkg := parsePackage(fset)

	// First pass: collect all needed imports by generating to a temp buffer
	var tempBuf bytes.Buffer
	generateTypes(&tempBuf, fset, docPkg)
	generateFuncs(&tempBuf, fset, docPkg)
	generateVars(&tempBuf, docPkg)
	generateConsts(&tempBuf, docPkg)

	// Build final output with proper imports
	var buf bytes.Buffer
	buf.WriteString("// Code generated by gen-exports. DO NOT EDIT.\n\n")
	buf.WriteString("package inflect\n\n")
	
	// Write import block
	if len(neededImports) == 0 {
		buf.WriteString(fmt.Sprintf("import %s %q\n\n", implAlias, importPath))
	} else {
		buf.WriteString("import (\n")
		buf.WriteString(fmt.Sprintf("\t%s %q\n", implAlias, importPath))
		for importPath := range neededImports {
			buf.WriteString(fmt.Sprintf("\t%q\n", importPath))
		}
		buf.WriteString(")\n\n")
	}

	// Write the actual generated code
	buf.Write(tempBuf.Bytes())

	writeOutput(buf.Bytes())
}

func parsePackage(fset *token.FileSet) *doc.Package {
	pkgs, err := parser.ParseDir(fset, internalPkg, func(fi os.FileInfo) bool {
		return !strings.HasSuffix(fi.Name(), "_test.go")
	}, parser.ParseComments)
	if err != nil {
		log.Fatalf("parsing %s: %v", internalPkg, err)
	}

	pkg, ok := pkgs["inflect"]
	if !ok {
		log.Fatalf("package 'inflect' not found in %s", internalPkg)
	}

	return doc.New(pkg, importPath, doc.AllDecls)
}

func generateTypes(buf *bytes.Buffer, fset *token.FileSet, docPkg *doc.Package) {
	for _, t := range docPkg.Types {
		if !ast.IsExported(t.Name) {
			continue
		}
		docComment := formatDoc(t.Doc)
		fmt.Fprintf(buf, "%stype %s = %s.%s\n\n", docComment, t.Name, implAlias, t.Name)

		// Export constants associated with this type (e.g., iota constants)
		for _, c := range t.Consts {
			for _, name := range c.Names {
				if ast.IsExported(name) {
					constDoc := formatDoc(c.Doc)
					fmt.Fprintf(buf, "%sconst %s = %s.%s\n\n", constDoc, name, implAlias, name)
				}
			}
		}

		// Export functions associated with this type (constructors, etc.)
		for _, f := range t.Funcs {
			if !ast.IsExported(f.Name) {
				continue
			}
			wrapper := generateFuncWrapper(fset, f)
			buf.WriteString(wrapper)
			buf.WriteString("\n")
		}
	}
}

func generateFuncs(buf *bytes.Buffer, fset *token.FileSet, docPkg *doc.Package) {
	for _, f := range docPkg.Funcs {
		if !ast.IsExported(f.Name) {
			continue
		}
		wrapper := generateFuncWrapper(fset, f)
		buf.WriteString(wrapper)
		buf.WriteString("\n")
	}
}

func generateVars(buf *bytes.Buffer, docPkg *doc.Package) {
	for _, v := range docPkg.Vars {
		for _, name := range v.Names {
			if ast.IsExported(name) {
				docComment := formatDoc(v.Doc)
				fmt.Fprintf(buf, "%svar %s = %s.%s\n\n", docComment, name, implAlias, name)
			}
		}
	}
}

func generateConsts(buf *bytes.Buffer, docPkg *doc.Package) {
	for _, c := range docPkg.Consts {
		for _, name := range c.Names {
			if ast.IsExported(name) {
				docComment := formatDoc(c.Doc)
				fmt.Fprintf(buf, "%sconst %s = %s.%s\n\n", docComment, name, implAlias, name)
			}
		}
	}
}

func writeOutput(content []byte) {
	formatted, err := format.Source(content)
	if err != nil {
		fmt.Fprintln(os.Stderr, "Warning: could not format output:", err)
		fmt.Fprintln(os.Stderr, "--- Raw output ---")
		_, _ = os.Stderr.Write(content)
		os.Exit(1)
	}

	if err := os.WriteFile(outputFile, formatted, 0o600); err != nil {
		log.Fatalf("writing %s: %v", outputFile, err)
	}

	fmt.Fprintf(os.Stderr, "Generated %s with exports from %s\n", outputFile, internalPkg)
}

func formatDoc(docStr string) string {
	if docStr == "" {
		return ""
	}
	docStr = strings.TrimSpace(docStr)
	lines := strings.Split(docStr, "\n")
	var out strings.Builder
	for _, line := range lines {
		out.WriteString("// ")
		out.WriteString(line)
		out.WriteString("\n")
	}
	return out.String()
}

func generateFuncWrapper(fset *token.FileSet, f *doc.Func) string {
	var buf bytes.Buffer

	// Add doc comment
	if f.Doc != "" {
		buf.WriteString(formatDoc(f.Doc))
	}

	// Get function signature from the AST
	decl := f.Decl
	funcType := decl.Type

	// Build parameter list
	params := formatFieldList(fset, funcType.Params)
	results := formatFieldList(fset, funcType.Results)

	// Build signature
	buf.WriteString(fmt.Sprintf("func %s(%s)", f.Name, params))

	if results != "" {
		if strings.Contains(results, ",") || strings.Contains(results, " ") {
			buf.WriteString(" (" + results + ")")
		} else {
			buf.WriteString(" " + results)
		}
	}

	// Build call
	callArgs := formatCallArgs(funcType.Params)
	buf.WriteString(" {\n")
	if funcType.Results != nil && len(funcType.Results.List) > 0 {
		buf.WriteString(fmt.Sprintf("\treturn %s.%s(%s)\n", implAlias, f.Name, callArgs))
	} else {
		buf.WriteString(fmt.Sprintf("\t%s.%s(%s)\n", implAlias, f.Name, callArgs))
	}
	buf.WriteString("}\n")

	return buf.String()
}

func formatFieldList(fset *token.FileSet, fl *ast.FieldList) string {
	if fl == nil || len(fl.List) == 0 {
		return ""
	}

	var parts []string
	for _, field := range fl.List {
		typeStr := exprToString(fset, field.Type)
		// Prefix types from our package with impl.
		typeStr = prefixInternalTypes(typeStr)

		if len(field.Names) == 0 {
			// Unnamed return value
			parts = append(parts, typeStr)
		} else {
			for _, name := range field.Names {
				parts = append(parts, fmt.Sprintf("%s %s", name.Name, typeStr))
			}
		}
	}
	return strings.Join(parts, ", ")
}

func formatCallArgs(fl *ast.FieldList) string {
	if fl == nil || len(fl.List) == 0 {
		return ""
	}

	var args []string
	for _, field := range fl.List {
		// Check if this is a variadic parameter
		_, isVariadic := field.Type.(*ast.Ellipsis)

		for _, name := range field.Names {
			if isVariadic {
				args = append(args, name.Name+"...")
			} else {
				args = append(args, name.Name)
			}
		}
	}
	return strings.Join(args, ", ")
}

func exprToString(fset *token.FileSet, expr ast.Expr) string {
	var buf bytes.Buffer
	if err := format.Node(&buf, fset, expr); err != nil {
		return "interface{}"
	}
	result := buf.String()
	
	// Track any standard library imports needed
	for typeStr, importPath := range stdLibImports {
		if strings.Contains(result, typeStr) {
			neededImports[importPath] = true
		}
	}
	
	return result
}

// prefixInternalTypes adds impl. prefix to types defined in our package.
func prefixInternalTypes(typeStr string) string {
	// Known types from our package that need prefixing
	knownTypes := []string{"Engine", "ClassicalMode", "Plurality", "PossessiveStyleType"}

	for _, t := range knownTypes {
		// Handle pointer types
		if typeStr == "*"+t {
			return "*" + implAlias + "." + t
		}
		// Handle slice types
		if typeStr == "[]"+t {
			return "[]" + implAlias + "." + t
		}
		// Handle direct type reference
		if typeStr == t {
			return implAlias + "." + t
		}
	}
	return typeStr
}
